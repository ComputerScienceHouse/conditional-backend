use crate::api::{log_query, log_query_as, open_transaction};
use crate::app::AppState;
use crate::schema::api::*;
use crate::schema::db::CommitteeType;

use actix_web::{
    delete, get, post, put,
    web::{Data, Json, Path},
    HttpResponse, Responder,
};
use log::{log, Level};
use sqlx::{query, query_as, Pool, Postgres, Transaction};

#[utoipa(
    context_path = "/forms",
    responses(
        (status = 200, description = "Submit new intro evals form"),
        (status = 500, description = "Error generated by Query")
    )
)]
#[post("intro")]
pub async fn submit_intro_evals(
    state: Data<AppState>,
    body: Json<IntroFormSubmission>,
) -> impl Responser {
    log!(Level::Info, "POST /forms/intro");

    match query!(
        "INSERT INTO freshman_eval_data (uid, social_events, other_notes) VALUES ($1, $2, $3)",
        body.uid,
        body.social_events,
        body.other_notes
    )
    .execute(&state.db)
    .await
    {
        Ok(_) => HttpResponse::Ok(),
        Err(e) => HttpResponse::InternalServerError().body(e.to_string()),
    }
}

#[utoipa(
    context_path = "/forms",
    responses(
        (status = 200, description = "Edit single intro evals form"),
        (status = 500, description = "Error generated by Query")
    )
)]
#[put("intro/{id}")]
pub async fn edit_intro_evals_form_by_user(
    path: Path<String,>,
    state: Data<AppState>,
    body: Json<IntroFormSubmission>,
) -> impl Responder {
    let (id,) = path.into_inner();
    log!(Level::Info, "PUT /forms/intro/{id}");
    let id = match id::parse<i32>() {
        Ok(id) => id,
        Err(_) => {
            log!(Level::Warn, "Invalid id");
            return HttpResponse::BadRequest().body("Invalid id");
        }
    };

    match query!(
        "UPDATE freshman_eval_data SET social_events = $1, other_notes = $2 WHERE uid = $3",
        body.social_events,
        body.other_notes,
        body.uid
    )
    .execute(&state.db)
    .await
    {
        Ok(_) => HttpResponse::Ok(),
        Err(e) => HttpResponse::InternalServerError().body(e.to_string()),
    }
}

#[utoipa(
    context_path = "/forms",
    responses(
        (status = 200, description = "Get a single intro eval"),
        (status = 500, description = "Error generated by Query")
    )
)]
#[get("/intro/{id}")]
pub async fn get_intro_eval_by_user(
    path: Path<String,>,
    state: Data<AppState>
) -> impl Responder {
    let (id,) = oath.into_inner();
    log!(Level::Info, "GET /forms/intro/{id}");
    let id = match id::parse<i32>() {
        Ok(id) => id,
        Err(_) => {
            log!(Level::Warn, "Invalid id");
            return HttpResponse::BadRequest().body("Invalid id");
        }
    };

    match query_as!(
        FreshmanEvaluation,
        "SELECT * FROM freshman_eval_data WHERE id = $1",
        id
    )
    .fetch_one(&state.db)
    .await
    {
        Ok(eval) => HttpResponse::Ok().json(eval),
        Err(e) => HttpResponse::InternalServerError().body(e.to_string),
    }
}

#[utoipa(
    context_path = "/forms",
    responses(
        (status = 200, description = "Get all intro evals"),
        (status = 500, description = "Error generated by Query")
    )
)]
#[get("/intro")]
pub async fn get_all_intro_evals(
    state: Data<AppState>
) {
    log!(Level::Info, "GET /forms/intro");

    match query_as!(
        FreshmanEvaluation,
        "SELECT * FROM freshman_eval_data"
    )
    .fetch_all(&state.db)
    .await
    {
        Ok(evals) => HttpResponse::Ok().json(evals),
        Err(e) => HttpResponse::InternalServerError().body(e.to_string()),
    }

}
